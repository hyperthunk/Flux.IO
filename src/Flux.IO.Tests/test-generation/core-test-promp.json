{
    "role": "you are the principle test engineer on our project, with a wealth of experience in property based and model-based testing",
    "task": "Build an enhanced integration test suite for the system under test, using FsCheck model-based testing",
    "system-under-test": "StreamProcessor within the I/O subsystem, at the heart of our non-blocking, stream processing framework",
    "prompt-attachements": {
        "Core.fs": "The implmentation module(s) of the system under test",
        "Generators.fs": "Random test data generators for FsCheck",
        "CoreMachine.fs": "Existing property based and model based tests",
        "CoreTests.fs": "Existing property based unit tests"
    },
    "required-outputs": {
        "test-plan": "a detailed test plan that explains the scenarios and interleavings that your tests will cover",
        "test-model": "a self-contained F# module that provides the test model and state machine (+transitions) for the tests",
        "test-module": "a self-contained F# module that provides all of the integration test properties, using FsCheck"
    },
    "requirements": {
        "model-use-in-machine.Next": "drive the choice of the next operation from the input state (i.e., the `model` parameter passed to `.Next`)",
        "stream-test-composition": {
            "all-scenarios": {
                "terminal-node": "your terminal node (in the stream) MUST produce json data using the generators in our `JsonGenerators` module"                
            },
            "chunking-scenarios": {
                "weighting": "a minimum of 30% of the test scenarios",
                "instructions": "insert a 'chunking' node after the json data generator, which simulates chunked async reading of raw data from a stream source (e.g., file or socket)",
                "test-flow": {
                    "stage-1": "generate random json data using our generators",
                    "stage-2": 
                        ["split this data up and feed it to the pipeline a proxy of a `System.IO.Pipelines.PipeReader`"
                        , "read from the proxy via `pipe.ReadAsync`"
                        , "slice the buffer and feed to the output as `ReadOnlyMemory<byte>`"
                        , "you may refer to `PipelineSource` in the `pipeline-io-framework.fs` attachement for reference"],
                    "stage-3": {
                        "description": "take the byte buffer from the input envelope and parse it asynchronously",
                        "instructions": [
                            "use Newtonsoft.Json to asynchronously parse the ReadOnlyMemory<byte> chunks as they arrive",
                            "pass the json tokens on downstream once they are available"
                        ]
                    },
                    "stage-4": {
                        "description": "simulate storing the json data in a K/V store",
                        "instructions": [
                            "scalar attribute-value pairs are written to a HashMap<string, boxedObject>",
                            "attributes that map to objects cause a record to be written into a HashMap<string, string>"
                        ]
                    }
                }
            },
            "accumulation-scenarios": {
                "weighting": "a minimum of 20% of the test scenarios",
                "instructions": [
                    "accumulate scalar json attributes into a HashMap<string, boxedObject> until a minimum threshold is reached",
                    "pass the accumulated attributes on to the next node once at the threshold",
                    "since the keys in the json data will be random, the threshold will need to be based on the number of keys read",
                    "the downstream should capture the domain of the dictionary that is passed to it (so we can verify its dependencies are fulfilled)"
                ]
            }        
        }
    },
    "constraints": {
        "default-dependencies": {
            "description": "please make use of the following dependencies and use them by default",
            "external-dependencies": [
                "FSharp.HashCollections (for HashMap and HashSet)",
                "FSharpPlus (for functors, monads, and arrows, and also for lenses to simplify accessing data structures in code)",
                "FSharpx.Collections (for additional collections and data structures if required)",
                "Newtonsoft.Json (for json parsing and serialization)"
            ]
        },
        "coding": {
            "language": "all code must be written in idiomatic F#",
            "coding-conventions": {
                "description": "you must adhere fully to these coding standards",
                "standards": {
                    "simplicity": "implementation should strive for simplicity without sacrificing any of the function or other non-functional requirements",
                    "readability": "code should be easy to read and understand, with clear naming conventions and consistent formatting",
                    "functional": "lean heavily into functional code and use FSharpPlus (for functors, monads, and arrows, and lenses) wherever possible",
                    "interface-naming": "internal interfaces should not be prefixed with an 'I'",
                    "idiomatic-fsharp": {
                        "description": "code should make use of F# idioms and best practices",
                        "correct-fsharp": "ensure your F# code does not use invalid constructs such as 'return' or 'break'; following the 'functional-programming' conventions will aid with this",
                        "functional-programming": {
                            "immutability-by-default": {
                                "variables": "avoid using mutable variables wherever possible",
                                "members-and-data-structures": "prefer immutable data structures and types except in performance-critical code",
                                "test-model-notes": "it is particularly important that the model of the SUT is immutable - model updates should only happen when `Run` is called"
                            },
                            "recursion-not-iteration": "always favour tail-call-optimised recursion over iteration where appropriate - avoid for and while loops whever possible",
                            "pipelining-vs-control-structures": {
                                "favour-composition": "use function composition and pipelining to build up complex operations, not loops",
                                "avoid-side-effects": "strive to avoid side effects in your functions, making them easier to reason about and compose - side-effecting code should be separated from pure code where possible"
                            },
                            "railway-oriented-programming": {
                                "error-handling": "use a railway-oriented approach to error handling, where errors are treated as first-class citizens and can be composed and transformed just like regular values"
                            }
                        }
                    }
                }
            }
        }        
    }
}