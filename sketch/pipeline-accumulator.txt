namespace AsyncPipeline.Accumulation

open System
open System.Collections.Concurrent
open System.Collections.Generic
open System.Threading
open System.Threading.Tasks
open AsyncPipeline.Core

// Accumulator stage implementation
type AccumulatorStage<'In, 'Out, 'Key, 'State when 'Key : equality>(
    accumulator: Accumulator<'In, 'Out, 'Key, 'State>,
    policy: AccumulatorPolicy,
    memoryPool: IMemoryPool,
    metrics: IMetrics) =
    
    let stateTable = ConcurrentDictionary<'Key, AccumulatorState<'Key, 'State>>()
    let spilledKeys = ConcurrentDictionary<'Key, ReadOnlyMemory<byte>>()
    let mutable context = Unchecked.defaultof<StageContext>
    let timerCts = new CancellationTokenSource()
    let mutable timerTask = Unchecked.defaultof<Task>
    
    let recordMetrics (action: string) (key: 'Key) =
        let tags = Map.ofList [("stage", accumulator.Id); ("action", action)]
        metrics.RecordCounter("accumulator_operations", tags, 1L)
        
    let checkThresholds (state: AccumulatorState<'Key, 'State>) =
        let exceedsItems = policy.MaxItems |> Option.map (fun max -> state.SizeItems >= max) |> Option.defaultValue false
        let exceedsBytes = policy.MaxBytes |> Option.map (fun max -> state.SizeBytes >= max) |> Option.defaultValue false
        exceedsItems || exceedsBytes
        
    let checkTTL (state: AccumulatorState<'Key, 'State>) (now: Timestamp) =
        match policy.CompletenessTTL with
        | Some ttl ->
            let elapsed = now - state.FirstTs
            elapsed > int64 ttl.TotalMilliseconds
        | None -> false
        
    let spillState (key: 'Key) (state: AccumulatorState<'Key, 'State>) =
        if policy.SpillAllowed then
            try
                let serialized = accumulator.SerializeSpill state
                spilledKeys.[key] <- serialized
                stateTable.TryRemove(key) |> ignore
                recordMetrics "spilled" key
                true
            with ex ->
                context.Logger.LogError($"Failed to spill state for key {key}", ex)
                false
        else
            false
            
    let reloadState (key: 'Key) =
        match spilledKeys.TryGetValue(key) with
        | true, serialized ->
            try
                let state = accumulator.DeserializeSpill serialized
                spilledKeys.TryRemove(key) |> ignore
                recordMetrics "reloaded" key
                Some state
            with ex ->
                context.Logger.LogError($"Failed to reload state for key {key}", ex)
                None
        | false, _ -> None
        
    let emitComplete (output: 'Out) (state: AccumulatorState<'Key, 'State>) (completeness: float) =
        let headers = 
            Map.ofList [
                ("acc.completeness", completeness.ToString())
                ("acc.spilled", (spilledKeys.ContainsKey(state.Key)).ToString())
            ]
        {
            Payload = output
            Headers = headers
            SeqId = 0L
            SpanCtx = { TraceId = ""; SpanId = ""; Baggage = Dictionary<_,_>() :> IReadOnlyDictionary<_,_> }
            Timestamp = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds()
            Attrs = Dictionary<_,_>() :> IReadOnlyDictionary<_,_>
            Cost = { Bytes = state.SizeBytes; CpuHint = 0.0 }
        }
        
    let processEnvelope (envelope: Envelope<'In>) =
        async {
            let key = accumulator.ExtractKey envelope
            let now = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds()
            
            // Get or reload state
            let currentState =
                match stateTable.TryGetValue(key) with
                | true, state -> Some state
                | false, _ -> reloadState key
                
            // Update state
            let updatedState = accumulator.UpdateState currentState envelope
            
            // Check thresholds
            let shouldCheckComplete = 
                checkThresholds updatedState || 
                checkTTL updatedState now
                
            if shouldCheckComplete then
                match accumulator.CheckComplete updatedState with
                | Complete(output, newState) ->
                    stateTable.TryRemove(key) |> ignore
                    recordMetrics "completed" key
                    return Some (emitComplete output updatedState 1.0)
                    
                | Expired(outputOpt, newState) when policy.PartialFlush ->
                    match outputOpt with
                    | Some output ->
                        stateTable.TryRemove(key) |> ignore
                        recordMetrics "partial_flush" key
                        return Some (emitComplete output updatedState updatedState.CompletenessScore)
                    | None ->
                        stateTable.[key] <- updatedState
                        return None
                        
                | Incomplete newState ->
                    stateTable.[key] <- updatedState
                    
                    // Check memory pressure and spill if needed
                    let totalMemory = stateTable.Values |> Seq.sumBy (fun s -> int64 s.SizeBytes)
                    if totalMemory > 1_000_000_000L then // 1GB threshold
                        // Spill oldest incomplete states
                        let toSpill = 
                            stateTable.ToArray()
                            |> Array.sortBy (fun kvp -> kvp.Value.FirstTs)
                            |> Array.take (min 10 (stateTable.Count /